<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Postural Analysis System</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            font-family: 'Arial', sans-serif;
            color: #e2e8f0;
            overflow-x: hidden;
        }
        h1 {
            font-family: 'Georgia', serif;
            font-size: 2.5rem;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        video {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 3px solid #d4af37;
            box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3);
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            object-fit: cover;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        video:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 30px rgba(212, 175, 55, 0.5);
        }
        canvas {
            border: 3px solid #a0aec0;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: none;
            height: auto;
            background: #2d3748;
        }
        .container {
            max-width: 7xl;
            margin: 0 auto;
            padding: 2rem;
        }
        .premium-card {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            border-radius: 15px;
            padding: 1.5rem;
            border-left: 5px solid #d4af37;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .premium-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(212, 175, 55, 0.4);
        }
        .status-incorrect {
            color: #ff6347;
            font-weight: 600;
            animation: pulse 1.5s infinite;
        }
        .status-correct {
            color: #4ade80;
            font-weight: 600;
        }
        button {
            background: linear-gradient(90deg, #d4af37 0%, #c0a062 100%);
            color: #1a202c;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(90deg, #c0a062 0%, #d4af37 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(212, 175, 55, 0.5);
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                align-items: center;
                padding: 1rem;
            }
            canvas {
                max-width: 100%;
            }
            video {
                top: 10px;
                right: 10px;
                width: 100px;
                height: 100px;
            }
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center">
    <h1 class="text-center mb-8">Postural Analysis System</h1>
    <div class="container flex flex-col md:flex-row gap-8 w-full">
        <div id="analyseView" class="flex-1 relative">
            <video id="video" autoplay class="mb-4"></video>
            <canvas id="canvas" class="mb-4"></canvas>
            <div class="flex gap-4 flex-wrap justify-center">
                <button onclick="startAnalysis()" class="mb-2">Start Analysis</button>
                <button onclick="switchCamera()" class="mb-2">Switch Camera</button>
            </div>
            <div id="analysis" class="p-6 mt-6">
                <p class="text-lg">Postural Status: <span id="postureStatus">Waiting for analysis...</span></p>
                <div id="postureDetails" class="premium-card hidden mt-4">
                    <p class="text-lg font-semibold text-yellow-400">Posture Feedback:</p>
                    <ul id="postureList" class="list-disc list-inside mt-2"></ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const postureStatus = document.getElementById('postureStatus');
        const postureDetails = document.getElementById('postureDetails');
        const postureList = document.getElementById('postureList');
        const analyseView = document.getElementById('analyseView');
        let currentFacingMode = 'environment';

        const postureThresholds = {
            head_inclination: 0.08,
            head_rotation: 0.15,
            shoulder_height_diff: 0.04,
            back_angle_min: 75,
            back_angle_max: 105,
            elbow_angle_min: 70,
            elbow_angle_max: 110,
            wrist_angle_max: 15,
            knee_angle_min: 80,
            knee_angle_max: 100,
            thigh_angle_min: 75,
            thigh_angle_max: 105
        };

        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
        });
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        pose.onResults(onResults);

        let camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 640,
            height: 480,
            facingMode: currentFacingMode
        });

        function startAnalysis() {
            camera.start();
            postureStatus.textContent = 'Analyzing posture...';
            postureDetails.classList.remove('hidden');
            canvasElement.width = analyseView.clientWidth;
            canvasElement.height = canvasElement.width * (480 / 640);
        }

        async function switchCamera() {
            try {
                await camera.stop();
                currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await pose.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480,
                    facingMode: currentFacingMode
                });
                await camera.start();
                postureStatus.textContent = `Analyzing posture (${currentFacingMode === 'environment' ? 'Back' : 'Front'} camera)...`;
            } catch (error) {
                alert('Error switching camera: ' + error.message);
            }
        }

        function onResults(results) {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

            if (results.poseLandmarks) {
                drawLandmarks(results.poseLandmarks);
                const analysis = analyzePosture(results.poseLandmarks);
                displayAnalysis(analysis);
            } else {
                postureStatus.textContent = 'Aucune personne détectée';
                postureList.innerHTML = '';
                postureDetails.classList.add('hidden');
            }
        }

        function drawLandmarks(landmarks) {
            canvasCtx.strokeStyle = '#d4af37';
            canvasCtx.lineWidth = 5;
            for (const landmark of landmarks) {
                canvasCtx.beginPath();
                canvasCtx.arc(landmark.x * canvasElement.width, landmark.y * canvasElement.height, 5, 0, 2 * Math.PI);
                canvasCtx.fillStyle = '#d4af37';
                canvasCtx.fill();
            }
            const connections = [[11, 12], [11, 13], [12, 14], [23, 24], [11, 23], [12, 24]];
            canvasCtx.strokeStyle = '#c0a062';
            canvasCtx.lineWidth = 10;
            for (const [start, end] of connections) {
                canvasCtx.beginPath();
                canvasCtx.moveTo(landmarks[start].x * canvasElement.width, landmarks[start].y * canvasElement.height);
                canvasCtx.lineTo(landmarks[end].x * canvasElement.width, landmarks[end].y * canvasElement.height);
                canvasCtx.stroke();
            }
        }

        function analyzePosture(landmarks) {
            const analysis = {
                person_detected: true,
                head: { status: 'Correcte', details: 'Position correcte' },
                neck: { status: 'Correcte', details: 'Position correcte' },
                shoulders: { status: 'Correcte', details: 'Position correcte' },
                back: { status: 'Correcte', details: 'Position correcte', position: null },
                elbows: { left: null, right: null, status: 'Correcte', details: 'Position correcte' },
                wrists: { left: null, right: null, status: 'Correcte', details: 'Position correcte' },
                thighs: { left: null, right: null, status: 'Correcte', details: 'Position correcte' },
                knees: { left: null, right: null, status: 'Correcte', details: 'Position correcte' },
                feet: { left: null, right: null, status: 'Correcte', details: 'Position correcte' },
                global_posture: 'Correcte',
                details: ''
            };

            const nose = landmarks[0];
            const leftEar = landmarks[7];
            const rightEar = landmarks[8];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftElbow = landmarks[13];
            const rightElbow = landmarks[14];
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];

            const earMidY = (leftEar.y + rightEar.y) / 2;
            const shoulderMidY = (leftShoulder.y + rightShoulder.y) / 2;
            const headInclination = earMidY - shoulderMidY;
            const headRotation = leftEar.x - rightEar.x;

            if (Math.abs(headInclination) > postureThresholds.head_inclination) {
                analysis.head.status = 'Incorrecte';
                analysis.head.details = headInclination > 0 ? 'Tête penchée vers l\'avant' : 'Tête penchée vers l\'arrière';
            }
            if (Math.abs(headRotation) > postureThresholds.head_rotation) {
                analysis.head.status = 'Incorrecte';
                analysis.head.details += analysis.head.details.includes('penchée') ? ' | Tête tournée' : 'Tête tournée';
            }

            if (Math.abs(headInclination) > postureThresholds.head_inclination * 0.7) {
                analysis.neck.status = 'Incorrecte';
                analysis.neck.details = 'Cou incliné';
            }
            if (Math.abs(headRotation) > postureThresholds.head_rotation * 0.7) {
                analysis.neck.status = 'Incorrecte';
                analysis.neck.details += analysis.neck.details.includes('incliné') ? ' | Cou tordu' : 'Cou tordu';
            }

            const shoulderHeightDiff = Math.abs(leftShoulder.y - rightShoulder.y);
            const shoulderHipAlignmentLeft = leftShoulder.x - leftHip.x;
            const shoulderHipAlignmentRight = rightShoulder.x - rightHip.x;
            const shoulderMidX = (leftShoulder.x + rightShoulder.x) / 2;
            const hipMidX = (leftHip.x + rightHip.x) / 2;
            const hipMidY = (leftHip.y + rightHip.y) / 2;
            const backAngle = (180 / Math.PI) * Math.atan2(hipMidY - shoulderMidY, hipMidX - shoulderMidX);
            analysis.back.position = { shoulder_mid: [shoulderMidX, shoulderMidY], hip_mid: [hipMidX, hipMidY], angle: backAngle };

            if (shoulderHeightDiff > postureThresholds.shoulder_height_diff) {
                analysis.shoulders.status = 'Incorrecte';
                analysis.shoulders.details = 'Épaules asymétriques';
            }
            if (Math.abs(shoulderHipAlignmentLeft) > 0.1 || Math.abs(shoulderHipAlignmentRight) > 0.1) {
                analysis.shoulders.status = 'Incorrecte';
                analysis.shoulders.details += analysis.shoulders.details.includes('asymétriques') ? ' | Épaules contractées' : 'Épaules contractées';
            }

            if (backAngle < postureThresholds.back_angle_min) {
                analysis.back.status = 'Incorrecte';
                analysis.back.details = 'Dos trop penché en avant';
            } else if (backAngle > postureThresholds.back_angle_max) {
                analysis.back.status = 'Incorrecte';
                analysis.back.details = 'Dos trop penché en arrière';
            }

            analysis.elbows.left = calculateAngle(leftShoulder, leftElbow, leftWrist);
            analysis.elbows.right = calculateAngle(rightShoulder, rightElbow, rightWrist);
            analysis.wrists.left = calculateWristAngle(leftElbow, leftWrist);
            analysis.wrists.right = calculateWristAngle(rightElbow, rightWrist);

            if (analysis.elbows.left < postureThresholds.elbow_angle_min || analysis.elbows.left > postureThresholds.elbow_angle_max) {
                analysis.elbows.status = 'Incorrecte';
                analysis.elbows.details = 'Coude gauche mal positionné';
            }
            if (analysis.elbows.right < postureThresholds.elbow_angle_min || analysis.elbows.right > postureThresholds.elbow_angle_max) {
                analysis.elbows.status = 'Incorrecte';
                analysis.elbows.details += analysis.elbows.details.includes('gauche') ? ' | Coude droit mal positionné' : 'Coude droit mal positionné';
            }

            if (Math.abs(analysis.wrists.left) > postureThresholds.wrist_angle_max) {
                analysis.wrists.status = 'Incorrecte';
                analysis.wrists.details = 'Poignet gauche cassé';
            }
            if (Math.abs(analysis.wrists.right) > postureThresholds.wrist_angle_max) {
                analysis.wrists.status = 'Incorrecte';
                analysis.wrists.details += analysis.wrists.details.includes('gauche') ? ' | Poignet droit cassé' : 'Poignet droit cassé';
            }

            analysis.thighs.left = calculateVerticalAngle(leftHip, leftKnee);
            analysis.thighs.right = calculateVerticalAngle(rightHip, rightKnee);
            analysis.knees.left = calculateAngle(leftHip, leftKnee, leftAnkle);
            analysis.knees.right = calculateAngle(rightHip, rightKnee, rightAnkle);

            if (analysis.thighs.left < postureThresholds.thigh_angle_min || analysis.thighs.left > postureThresholds.thigh_angle_max) {
                analysis.thighs.status = 'Incorrecte';
                analysis.thighs.details = 'Cuisse gauche mal positionnée';
            }
            if (analysis.thighs.right < postureThresholds.thigh_angle_min || analysis.thighs.right > postureThresholds.thigh_angle_max) {
                analysis.thighs.status = 'Incorrecte';
                analysis.thighs.details += analysis.thighs.details.includes('gauche') ? ' | Cuisse droite mal positionnée' : 'Cuisse droite mal positionnée';
            }

            if (analysis.knees.left < postureThresholds.knee_angle_min || analysis.knees.left > postureThresholds.knee_angle_max) {
                analysis.knees.status = 'Incorrecte';
                analysis.knees.details = 'Genou gauche mal positionné';
            }
            if (analysis.knees.right < postureThresholds.knee_angle_min || analysis.knees.right > postureThresholds.knee_angle_max) {
                analysis.knees.status = 'Incorrecte';
                analysis.knees.details += analysis.knees.details.includes('gauche') ? ' | Genou droit mal positionné' : 'Genou droit mal positionné';
            }

            if (Math.abs(leftAnkle.y - rightAnkle.y) > 0.1) {
                analysis.feet.status = 'Incorrecte';
                analysis.feet.details = 'Jambes croisées ou suspendues';
            }

            const components = ['head', 'neck', 'shoulders', 'back', 'elbows', 'wrists', 'thighs', 'knees', 'feet'];
            for (const comp of components) {
                if (analysis[comp].status === 'Incorrecte') {
                    analysis.global_posture = 'Incorrecte';
                    break;
                }
            }

            return analysis;
        }

        function calculateAngle(a, b, c) {
            const ba = [a.x - b.x, a.y - b.y];
            const bc = [c.x - b.x, c.y - b.y];
            const cosineAngle = (ba[0] * bc[0] + ba[1] * bc[1]) / (Math.sqrt(ba[0]**2 + ba[1]**2) * Math.sqrt(bc[0]**2 + bc[1]**2));
            return (180 / Math.PI) * Math.acos(Math.min(Math.max(cosineAngle, -1), 1));
        }

        function calculateVerticalAngle(a, b) {
            const vertical = [0, -1];
            const ab = [b.x - a.x, b.y - a.y];
            const cosineAngle = (vertical[0] * ab[0] + vertical[1] * ab[1]) / (Math.sqrt(ab[0]**2 + ab[1]**2));
            return (180 / Math.PI) * Math.acos(Math.min(Math.max(cosineAngle, -1), 1));
        }

        function calculateWristAngle(elbow, wrist) {
            const forearmVector = [wrist.x - elbow.x, wrist.y - elbow.y];
            const vertical = [0, 1];
            const cosineAngle = (forearmVector[0] * vertical[0] + forearmVector[1] * vertical[1]) / (Math.sqrt(forearmVector[0]**2 + forearmVector[1]**2));
            return (180 / Math.PI) * Math.acos(Math.min(Math.max(cosineAngle, -1), 1));
        }

        function displayAnalysis(analysis) {
            postureStatus.textContent = analysis.global_posture;
            postureStatus.className = analysis.global_posture === 'Correcte' ? 'text-green-400 font-semibold' : 'text-red-400 font-semibold';

            postureList.innerHTML = '';
            const components = [
                { key: 'head', label: 'Tête' },
                { key: 'neck', label: 'Cou' },
                { key: 'shoulders', label: 'Épaules' },
                { key: 'back', label: 'Dos' },
                { key: 'elbows', label: 'Coudes' },
                { key: 'wrists', label: 'Poignets' },
                { key: 'thighs', label: 'Cuisses' },
                { key: 'knees', label: 'Genoux' },
                { key: 'feet', label: 'Pieds' }
            ];

            for (const { key, label } of components) {
                const li = document.createElement('li');
                li.textContent = `${label}: ${analysis[key].details}`;
                li.className = analysis[key].status === 'Correcte' ? 'status-correct' : 'status-incorrect';
                postureList.appendChild(li);
            }

            postureDetails.classList.remove('hidden');

            if (analysis.back.position) {
                const shoulderMid = analysis.back.position.shoulder_mid;
                const hipMid = analysis.back.position.hip_mid;
                canvasCtx.beginPath();
                canvasCtx.moveTo(shoulderMid[0] * canvasElement.width, shoulderMid[1] * canvasElement.height);
                canvasCtx.lineTo(hipMid[0] * canvasElement.width, hipMid[1] * canvasElement.height);
                canvasCtx.strokeStyle = analysis.back.status === 'Correcte' ? '#c0a062' : '#ff6347';
                canvasCtx.lineWidth = 10;
                canvasCtx.stroke();

                const backAngle = analysis.back.position.angle;
                const midPoint = [
                    (shoulderMid[0] * canvasElement.width + hipMid[0] * canvasElement.width) / 2 + 50,
                    (shoulderMid[1] * canvasElement.height + hipMid[1] * canvasElement.height) / 2
                ];
                canvasCtx.fillStyle = '#d4af37';
                canvasCtx.font = '16px Arial';
                canvasCtx.fillText(`Back Angle: ${Math.round(backAngle)}°`, midPoint[0], midPoint[1]);
            }
        }
    </script>
</body>
</html>